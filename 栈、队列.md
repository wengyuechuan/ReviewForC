# 栈和队列

## 栈的相关操作

```cpp
// 2019年数据结构链表大题解答
#include <iostream>
using namespace std;

#define MaxSize 5
#define ElemType int

// 这里使用王道C语言督学营当中给出的定义
// 对于操作系统内部的栈，一般top是指向第一个空单元的
// 而王道书当中的栈，是指向最高的满单元的
typedef struct {
    ElemType data[MaxSize]; //数组
    int top;
}SqStack;

// 初始化栈
void InitStack(SqStack &S){
    S.top = -1; // 当前栈为空
}

// 判断是否为空
bool StackEmpty(SqStack &S){
    if(-1 == S.top){
        return true;
    }else{
        return false;
    }
}

// 入栈
bool Push(SqStack &S, ElemType x){
    if(MaxSize - 1 == S.top){
        return false;
    }
    S.data[++S.top] = x;
    return true;
}

// 出栈
bool Pop(SqStack &S, ElemType &x){
    if(StackEmpty(S)){
        return false;
    }

    x = S.data[S.top--];
    return true;
}

// 读取栈顶元素
bool GetTop(SqStack &S, ElemType &x){
    if(-1 == S.top){
        return false;
    }
    x = S.data[S.top];
    return true;
}
int main(void){
    SqStack  S;
    InitStack(S);
    int x;
    for(int i = 0; i < 3; i++){
        cin >> x;
        Push(S, x);
    }
    for (int i = 0; i < 3; ++i) {
        Pop(S, x);
        printf("%2d",x);
    }
    return 0;
}
```

## 队列的相关操作

```cpp
#include <iostream>
using namespace std;
#define MaxSize 5
#define ElemType int

// 这里也是C语言督学营当中的代码实现
// 这里的实现是利用了一个附加空间来实现的，队尾永远指向空单元
typedef struct {
    ElemType data[MaxSize]; // 数组，存储MaxSize个元素
    int front,rear; // 队列头 队列尾
}SqQueue;

// 初始化
void InitQueue(SqQueue &Q){
    Q.rear = Q.front = 0;
}

// 判空
// 队尾永远指向空单元
bool isEmpty(SqQueue &Q){
    if(Q.rear == Q.front){ // 此时头和尾指针指向同一个位置，代表当前是空的
        return true;
    }
    return false;
}

// 判满
bool isFull(SqQueue &Q){
    if((Q.rear+1) % MaxSize == Q.front){ // 判断是否队伍是满的
        return true;
    }
    return false;
}

// 入队
bool EnQueue(SqQueue &Q, ElemType x){
    if(isFull(Q)){ // 如果此时是满的
        return false;
    }
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear+1) % MaxSize;
    return true;
}

// 出队
bool DeQueue(SqQueue &Q, ElemType &x){
    // 如果是空的话
    if(isFull(Q)){
        return false;
    }
    x = Q.data[Q.front];
    Q.front = (Q.front+1) % MaxSize;

    return true;
}

int main() {
    SqQueue queue;
    InitQueue(queue);
  
    return 0;
}

```
